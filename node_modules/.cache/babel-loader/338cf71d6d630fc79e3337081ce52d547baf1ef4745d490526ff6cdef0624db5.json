{"ast":null,"code":"\"use strict\";\n\nvar defaultMarks = ['strong', 'em', 'code', 'underline', 'strike-through'];\nvar buildMarksTree = function buildMarksTree(block) {\n  var children = block.children,\n    markDefs = block.markDefs;\n  if (!children || !children.length) {\n    return [];\n  }\n  var sortedMarks = children.map(sortMarksByOccurences);\n  var rootNode = {\n    _type: 'span',\n    children: []\n  };\n  var nodeStack = [rootNode];\n  children.forEach(function (span, i) {\n    var marksNeeded = sortedMarks[i];\n    if (!marksNeeded) {\n      var lastNode = nodeStack[nodeStack.length - 1];\n      lastNode.children.push(span);\n      return;\n    }\n    var pos = 1; // Start at position one. Root is always plain and should never be removed. (?)\n\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        var mark = nodeStack[pos].markKey;\n        var index = marksNeeded.indexOf(mark); // eslint-disable-next-line max-depth\n\n        if (index === -1) {\n          break;\n        }\n        marksNeeded.splice(index, 1);\n      }\n    } // Keep from beginning to first miss\n\n    nodeStack = nodeStack.slice(0, pos); // Add needed nodes\n\n    var currentNode = findLastParentNode(nodeStack);\n    marksNeeded.forEach(function (mark) {\n      var node = {\n        _type: 'span',\n        _key: span._key,\n        children: [],\n        mark: markDefs.find(function (def) {\n          return def._key === mark;\n        }) || mark,\n        markKey: mark\n      };\n      currentNode.children.push(node);\n      nodeStack.push(node);\n      currentNode = node;\n    }); // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n\n    if (isTextSpan(span)) {\n      var lines = span.text.split('\\n');\n      for (var line = lines.length; line-- > 1;) {\n        lines.splice(line, 0, '\\n');\n      }\n      currentNode.children = currentNode.children.concat(lines);\n    } else {\n      currentNode.children = currentNode.children.concat(span);\n    }\n  });\n  return rootNode.children;\n}; // We want to sort all the marks of all the spans in the following order:\n// 1. Marks that are shared amongst the most adjacent siblings\n// 2. Non-default marks (links, custom metadata)\n// 3. Built-in, plain marks (bold, emphasis, code etc)\n\nfunction sortMarksByOccurences(span, i, spans) {\n  if (!span.marks || span.marks.length === 0) {\n    return span.marks || [];\n  }\n  var markOccurences = span.marks.reduce(function (occurences, mark) {\n    occurences[mark] = occurences[mark] ? occurences[mark] + 1 : 1;\n    for (var siblingIndex = i + 1; siblingIndex < spans.length; siblingIndex++) {\n      var sibling = spans[siblingIndex];\n      if (sibling.marks && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {\n        occurences[mark]++;\n      } else {\n        break;\n      }\n    }\n    return occurences;\n  }, {});\n  var sortByOccurence = sortMarks.bind(null, markOccurences); // Slicing because sort() mutates the input\n\n  return span.marks.slice().sort(sortByOccurence);\n}\nfunction sortMarks(occurences, markA, markB) {\n  var aOccurences = occurences[markA] || 0;\n  var bOccurences = occurences[markB] || 0;\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences;\n  }\n  var aDefaultPos = defaultMarks.indexOf(markA);\n  var bDefaultPos = defaultMarks.indexOf(markB); // Sort default marks last\n\n  if (aDefaultPos !== bDefaultPos) {\n    return aDefaultPos - bDefaultPos;\n  } // Sort other marks simply by key\n\n  if (markA < markB) {\n    return -1;\n  } else if (markA > markB) {\n    return 1;\n  }\n  return 0;\n}\nfunction isTextSpan(node) {\n  return node._type === 'span' && typeof node.text === 'string' && (Array.isArray(node.marks) || typeof node.marks === 'undefined');\n}\nfunction findLastParentNode(nodes) {\n  for (var i = nodes.length - 1; i >= 0; i--) {\n    var node = nodes[i];\n    if (node._type === 'span' && node.children) {\n      return node;\n    }\n  }\n  return undefined;\n}\nmodule.exports = buildMarksTree;","map":{"version":3,"names":["defaultMarks","buildMarksTree","block","children","markDefs","length","sortedMarks","map","sortMarksByOccurences","rootNode","_type","nodeStack","forEach","span","i","marksNeeded","lastNode","push","pos","mark","markKey","index","indexOf","splice","slice","currentNode","findLastParentNode","node","_key","find","def","isTextSpan","lines","text","split","line","concat","spans","marks","markOccurences","reduce","occurences","siblingIndex","sibling","Array","isArray","sortByOccurence","sortMarks","bind","sort","markA","markB","aOccurences","bOccurences","aDefaultPos","bDefaultPos","nodes","undefined","module","exports"],"sources":["C:\\Projects\\seattle-community-fridge\\node_modules\\@sanity\\block-content-to-hyperscript\\src\\buildMarksTree.js"],"sourcesContent":["const defaultMarks = ['strong', 'em', 'code', 'underline', 'strike-through']\n\nconst buildMarksTree = block => {\n  const {children, markDefs} = block\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n  const rootNode = {_type: 'span', children: []}\n  let nodeStack = [rootNode]\n\n  children.forEach((span, i) => {\n    const marksNeeded = sortedMarks[i]\n    if (!marksNeeded) {\n      const lastNode = nodeStack[nodeStack.length - 1]\n      lastNode.children.push(span)\n      return\n    }\n\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed. (?)\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos].markKey\n        const index = marksNeeded.indexOf(mark)\n        // eslint-disable-next-line max-depth\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = findLastParentNode(nodeStack)\n    marksNeeded.forEach(mark => {\n      const node = {\n        _type: 'span',\n        _key: span._key,\n        children: [],\n        mark: markDefs.find(def => def._key === mark) || mark,\n        markKey: mark\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    })\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(lines)\n    } else {\n      currentNode.children = currentNode.children.concat(span)\n    }\n  })\n\n  return rootNode.children\n}\n\n// We want to sort all the marks of all the spans in the following order:\n// 1. Marks that are shared amongst the most adjacent siblings\n// 2. Non-default marks (links, custom metadata)\n// 3. Built-in, plain marks (bold, emphasis, code etc)\nfunction sortMarksByOccurences(span, i, spans) {\n  if (!span.marks || span.marks.length === 0) {\n    return span.marks || []\n  }\n\n  const markOccurences = span.marks.reduce((occurences, mark) => {\n    occurences[mark] = occurences[mark] ? occurences[mark] + 1 : 1\n\n    for (let siblingIndex = i + 1; siblingIndex < spans.length; siblingIndex++) {\n      const sibling = spans[siblingIndex]\n\n      if (sibling.marks && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n\n    return occurences\n  }, {})\n\n  const sortByOccurence = sortMarks.bind(null, markOccurences)\n\n  // Slicing because sort() mutates the input\n  return span.marks.slice().sort(sortByOccurence)\n}\n\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA] || 0\n  const bOccurences = occurences[markB] || 0\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aDefaultPos = defaultMarks.indexOf(markA)\n  const bDefaultPos = defaultMarks.indexOf(markB)\n\n  // Sort default marks last\n  if (aDefaultPos !== bDefaultPos) {\n    return aDefaultPos - bDefaultPos\n  }\n\n  // Sort other marks simply by key\n  if (markA < markB) {\n    return -1\n  } else if (markA > markB) {\n    return 1\n  }\n\n  return 0\n}\n\nfunction isTextSpan(node) {\n  return (\n    node._type === 'span' &&\n    typeof node.text === 'string' &&\n    (Array.isArray(node.marks) || typeof node.marks === 'undefined')\n  )\n}\n\nfunction findLastParentNode(nodes) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    const node = nodes[i]\n    if (node._type === 'span' && node.children) {\n      return node\n    }\n  }\n\n  return undefined\n}\n\nmodule.exports = buildMarksTree\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}