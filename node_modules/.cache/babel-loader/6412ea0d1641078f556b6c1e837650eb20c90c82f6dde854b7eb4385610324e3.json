{"ast":null,"code":"\"use strict\";\n\nvar objectAssign = require('object-assign');\n/* eslint-disable max-depth, complexity */\n\nfunction nestLists(blocks) {\n  var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'html';\n  var tree = [];\n  var currentList;\n  for (var i = 0; i < blocks.length; i++) {\n    var block = blocks[i];\n    if (!isListBlock(block)) {\n      tree.push(block);\n      currentList = null;\n      continue;\n    } // Start of a new list?\n\n    if (!currentList) {\n      currentList = listFromBlock(block);\n      tree.push(currentList);\n      continue;\n    } // New list item within same list?\n\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block);\n      continue;\n    } // Different list props, are we going deeper?\n\n    if (block.level > currentList.level) {\n      var newList = listFromBlock(block);\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // We actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n        // Clone the last child while adding our new list as the last child of it\n        var lastListItem = lastChild(currentList);\n        var newLastChild = objectAssign({}, lastListItem, {\n          children: lastListItem.children.concat(newList)\n        }); // Swap the last child\n\n        currentList.children[currentList.children.length - 1] = newLastChild;\n      } else {\n        currentList.children.push(newList);\n      } // Set the newly created, deeper list as the current\n\n      currentList = newList;\n      continue;\n    } // Different list props, are we going back up the tree?\n\n    if (block.level < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      var match = findListMatching(tree[tree.length - 1], block);\n      if (match) {\n        currentList = match;\n        currentList.children.push(block);\n        continue;\n      } // Similar parent can't be found, assume new list\n\n      currentList = listFromBlock(block);\n      tree.push(currentList);\n      continue;\n    } // Different list props, different list style?\n\n    if (block.listItem !== currentList.listItem) {\n      var _match = findListMatching(tree[tree.length - 1], {\n        level: block.level\n      });\n      if (_match && _match.listItem === block.listItem) {\n        currentList = _match;\n        currentList.children.push(block);\n        continue;\n      } else {\n        currentList = listFromBlock(block);\n        tree.push(currentList);\n        continue;\n      }\n    } // eslint-disable-next-line no-console\n\n    console.warn('Unknown state encountered for block', block);\n    tree.push(block);\n  }\n  return tree;\n}\nfunction isListBlock(block) {\n  return Boolean(block.listItem);\n}\nfunction blockMatchesList(block, list) {\n  return block.level === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block) {\n  return {\n    _type: 'list',\n    _key: \"\".concat(block._key, \"-parent\"),\n    level: block.level,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\nfunction lastChild(block) {\n  return block.children && block.children[block.children.length - 1];\n}\nfunction findListMatching(rootNode, matching) {\n  var filterOnType = typeof matching.listItem === 'string';\n  if (rootNode._type === 'list' && rootNode.level === matching.level && filterOnType && rootNode.listItem === matching.listItem) {\n    return rootNode;\n  }\n  var node = lastChild(rootNode);\n  if (!node) {\n    return false;\n  }\n  return findListMatching(node, matching);\n}\nmodule.exports = nestLists;","map":{"version":3,"names":["objectAssign","require","nestLists","blocks","mode","arguments","length","undefined","tree","currentList","i","block","isListBlock","push","listFromBlock","blockMatchesList","children","level","newList","lastListItem","lastChild","newLastChild","concat","match","findListMatching","listItem","_match","console","warn","Boolean","list","_type","_key","rootNode","matching","filterOnType","node","module","exports"],"sources":["C:\\Projects\\seattle-community-fridge\\node_modules\\@sanity\\block-content-to-hyperscript\\src\\nestLists.js"],"sourcesContent":["const objectAssign = require('object-assign')\n\n/* eslint-disable max-depth, complexity */\nfunction nestLists(blocks, mode = 'html') {\n  const tree = []\n  let currentList\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!isListBlock(block)) {\n      tree.push(block)\n      currentList = null\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if (block.level > currentList.level) {\n      const newList = listFromBlock(block)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // We actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = lastChild(currentList)\n        const newLastChild = objectAssign({}, lastListItem, {\n          children: lastListItem.children.concat(newList)\n        })\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        currentList.children.push(newList)\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if (block.level < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const match = findListMatching(tree[tree.length - 1], block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const match = findListMatching(tree[tree.length - 1], {level: block.level})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction isListBlock(block) {\n  return Boolean(block.listItem)\n}\n\nfunction blockMatchesList(block, list) {\n  return block.level === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(block) {\n  return {\n    _type: 'list',\n    _key: `${block._key}-parent`,\n    level: block.level,\n    listItem: block.listItem,\n    children: [block]\n  }\n}\n\nfunction lastChild(block) {\n  return block.children && block.children[block.children.length - 1]\n}\n\nfunction findListMatching(rootNode, matching) {\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    rootNode._type === 'list' &&\n    rootNode.level === matching.level &&\n    (filterOnType && rootNode.listItem === matching.listItem)\n  ) {\n    return rootNode\n  }\n\n  const node = lastChild(rootNode)\n  if (!node) {\n    return false\n  }\n\n  return findListMatching(node, matching)\n}\n\nmodule.exports = nestLists\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}